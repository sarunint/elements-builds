{"version":3,"file":"create-custom-element.js","sourceRoot":"","sources":["../../../../../packages/elements/src/create-custom-element.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, Type} from '@angular/core';\nimport {Subscription} from 'rxjs';\n\nimport {ComponentNgElementStrategyFactory} from './component-factory-strategy';\nimport {NgElementStrategy, NgElementStrategyFactory} from './element-strategy';\nimport {createCustomEvent, getComponentInputs, getDefaultAttributeToPropertyInputs} from './utils';\n\n/**\n * Prototype for a class constructor based on an Angular component\n * that can be used for custom element registration. Implemented and returned\n * by the {@link createCustomElement createCustomElement() function}.\n *\n * @publicApi\n */\nexport interface NgElementConstructor<P> {\n  /**\n   * An array of observed attribute names for the custom element,\n   * derived by transforming input property names from the source component.\n   */\n  readonly observedAttributes: string[];\n\n  /**\n   * Initializes a constructor instance.\n   * @param injector The source component's injector.\n   */\n  new (injector: Injector): NgElement&WithProperties<P>;\n}\n\n/**\n * Implements the functionality needed for a custom element.\n *\n * @publicApi\n */\nexport abstract class NgElement extends HTMLElement {\n  /**\n   * The strategy that controls how a component is transformed in a custom element.\n   */\n  // TODO(issue/24571): remove '!'.\n  protected ngElementStrategy !: NgElementStrategy;\n  /**\n   * A subscription to change, connect, and disconnect events in the custom element.\n   */\n  protected ngElementEventsSubscription: Subscription|null = null;\n\n  /**\n    * Prototype for a handler that responds to a change in an observed attribute.\n    * @param attrName The name of the attribute that has changed.\n    * @param oldValue The previous value of the attribute.\n    * @param newValue The new value of the attribute.\n    * @param namespace The namespace in which the attribute is defined.\n    * @returns Nothing.\n    */\n  abstract attributeChangedCallback(\n      attrName: string, oldValue: string|null, newValue: string, namespace?: string): void;\n  /**\n   * Prototype for a handler that responds to the insertion of the custom element in the DOM.\n   * @returns Nothing.\n   */\n  abstract connectedCallback(): void;\n  /**\n   * Prototype for a handler that responds to the deletion of the custom element from the DOM.\n   * @returns Nothing.\n   */\n  abstract disconnectedCallback(): void;\n}\n\n/**\n * Additional type information that can be added to the NgElement class,\n * for properties that are added based\n * on the inputs and methods of the underlying component.\n *\n * @publicApi\n */\nexport type WithProperties<P> = {\n  [property in keyof P]: P[property]\n};\n\n/**\n * A configuration that initializes an NgElementConstructor with the\n * dependencies and strategy it needs to transform a component into\n * a custom element class.\n *\n * @publicApi\n */\nexport interface NgElementConfig {\n  /**\n   * The injector to use for retrieving the component's factory.\n   */\n  injector: Injector;\n  /**\n   * An optional custom strategy factory to use instead of the default.\n   * The strategy controls how the transformation is performed.\n   */\n  strategyFactory?: NgElementStrategyFactory;\n}\n\n/**\n *  @description Creates a custom element class based on an Angular component.\n *\n * Builds a class that encapsulates the functionality of the provided component and\n * uses the configuration information to provide more context to the class.\n * Takes the component factory's inputs and outputs to convert them to the proper\n * custom element API and add hooks to input changes.\n *\n * The configuration's injector is the initial injector set on the class,\n * and used by default for each created instance.This behavior can be overridden with the\n * static property to affect all newly created instances, or as a constructor argument for\n * one-off creations.\n *\n * @param component The component to transform.\n * @param config A configuration that provides initialization information to the created class.\n * @returns The custom-element construction class, which can be registered with\n * a browser's `CustomElementRegistry`.\n *\n * @publicApi\n */\nexport function createCustomElement<P>(\n    component: Type<any>, config: NgElementConfig): NgElementConstructor<P> {\n  const inputs = getComponentInputs(component, config.injector);\n\n  const strategyFactory =\n      config.strategyFactory || new ComponentNgElementStrategyFactory(component, config.injector);\n\n  const attributeToPropertyInputs = getDefaultAttributeToPropertyInputs(inputs);\n\n  class NgElementImpl extends NgElement {\n    // Work around a bug in closure typed optimizations(b/79557487) where it is not honoring static\n    // field externs. So using quoted access to explicitly prevent renaming.\n    static readonly['observedAttributes'] = Object.keys(attributeToPropertyInputs);\n\n    constructor(injector?: Injector) {\n      super();\n\n      // Note that some polyfills (e.g. document-register-element) do not call the constructor.\n      // Do not assume this strategy has been created.\n      // TODO(andrewseguin): Add e2e tests that cover cases where the constructor isn't called. For\n      // now this is tested using a Google internal test suite.\n      this.ngElementStrategy = strategyFactory.create(injector || config.injector);\n    }\n\n    attributeChangedCallback(\n        attrName: string, oldValue: string|null, newValue: string, namespace?: string): void {\n      if (!this.ngElementStrategy) {\n        this.ngElementStrategy = strategyFactory.create(config.injector);\n      }\n\n      const propName = attributeToPropertyInputs[attrName] !;\n      this.ngElementStrategy.setInputValue(propName, newValue);\n    }\n\n    connectedCallback(): void {\n      if (!this.ngElementStrategy) {\n        this.ngElementStrategy = strategyFactory.create(config.injector);\n      }\n\n      this.ngElementStrategy.connect(this);\n\n      // Listen for events from the strategy and dispatch them as custom events\n      this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(e => {\n        const customEvent = createCustomEvent(this.ownerDocument !, e.name, e.value);\n        this.dispatchEvent(customEvent);\n      });\n    }\n\n    disconnectedCallback(): void {\n      if (this.ngElementStrategy) {\n        this.ngElementStrategy.disconnect();\n      }\n\n      if (this.ngElementEventsSubscription) {\n        this.ngElementEventsSubscription.unsubscribe();\n        this.ngElementEventsSubscription = null;\n      }\n    }\n  }\n\n  // Add getters and setters to the prototype for each property input. If the config does not\n  // contain property inputs, use all inputs by default.\n  inputs.map(({propName}) => propName).forEach(property => {\n    Object.defineProperty(NgElementImpl.prototype, property, {\n      get: function() { return this.ngElementStrategy.getInputValue(property); },\n      set: function(newValue: any) { this.ngElementStrategy.setInputValue(property, newValue); },\n      configurable: true,\n      enumerable: true,\n    });\n  });\n\n  return (NgElementImpl as any) as NgElementConstructor<P>;\n}\n"]}